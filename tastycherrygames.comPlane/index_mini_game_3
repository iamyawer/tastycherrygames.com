<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>PlaneRacingMadness</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
  </head>
  <body>
    <div id="unity-container" class="unity-desktop">
      <canvas id="unity-canvas" width=1344 height=756></canvas>
      <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
          <div id="unity-progress-bar-full"></div>
        </div>
      </div>
      <div id="unity-warning"> </div>
      <div id="unity-footer">
        <div id="unity-webgl-logo"></div>
        <div id="unity-fullscreen-button"></div>
        <div id="unity-build-title">Plugin by <a href="https://tastycherrygames.com" rel="dofollow">Tasty <span style="color: red;">Cherry</span> Games</a></div>
      </div>
    </div>
	<script src="tastycherrygames.com.js"></script>
    <script>
window.onload = function() {
    var script = document.createElement('script');
    script.src = 'a1.js';
    document.body.appendChild(script);
};
</script>




    </script>

	<!--<script src="https://tastycherrygames.com/games/js/runtimejs.js"></script> -->





	  <script>


		  (function () {


  const C = {


    transparentBackground: true, // false = solid background


    unityYellow: "#fbc02d",


    unityBlue: "#1e88e5",


    obstacleColor: "#ff6b6b",    // soft red


    bananaColor: "#ffd54f",


    groundHeight: 6


  };





  let canvas, ctx, raf, audio;


  let score = 0, high = +localStorage.lgHS || 0;


  let gameOver = false, run = true, prog = 0, frame = 0;


  let finishAnim = false, finishFrame = 0;





  const ASPECT = 600 / 180;


  let canvasWidth, canvasHeight, scale = 1;





  const G = {


    w: 600, h: 180,


    groundY: 140,


    y: 0, v: 0, g: 0.8, j: -12,


    speed: 4,


    obs: [],


    bananas: []


  };





  const minion = [


    "0011111100",


    "0111111110",


    "1111111111",


    "1100110011",


    "1111111111",


    "0111111110",


    "0011111100"


  ];





  function beep(f = 400, d = 0.05) {


    audio ||= new AudioContext();


    const o = audio.createOscillator();


    const g = audio.createGain();


    o.frequency.value = f;


    g.gain.value = 0.05;


    o.connect(g);


    g.connect(audio.destination);


    o.start();


    o.stop(audio.currentTime + d);


  }





  function spawnObstacle() {


    G.obs.push({ x: G.w + 200, w: 12, offset: Math.random() * 4 });


    if (Math.random() < 0.5)


      G.bananas.push({ x: G.w + 260, y: G.groundY - 38 });


  }





  function reset() {


    G.y = G.v = 0;


    G.speed = 4;


    G.obs = [];


    G.bananas = [];


    score = 0;


    gameOver = false;


    for (let i = 0; i < 3; i++) spawnObstacle();


  }





  function jump() {


    if (gameOver) return reset();


    if (G.y === 0) {


      G.v = G.j;


      beep(600);


    }


  }





  function drawMinion(x, y) {


    const p = 3;


    minion.forEach((r, ry) => {


      [...r].forEach((c, rx) => {


        if (c === "1") {


          ctx.fillStyle = C.unityYellow;


          ctx.fillRect((x + rx * p) * scale, (y + ry * p) * scale, p * scale, p * scale);


        }


      });


    });





    ctx.fillStyle = "#ccc"; // goggles


    ctx.fillRect(3*p*scale + x*scale, 3*p*scale + y*scale, 2*p*scale, p*scale);


    ctx.fillRect(6*p*scale + x*scale, 3*p*scale + y*scale, 2*p*scale, p*scale);





    ctx.fillStyle = "#000"; // eyes


    ctx.fillRect(4*p*scale + x*scale, 4*p*scale + y*scale, p*scale, p*scale);


    ctx.fillRect(7*p*scale + x*scale, 4*p*scale + y*scale, p*scale, p*scale);





    // animated legs


    ctx.fillStyle = C.unityBlue;


    ctx.fillRect((3*p + (frame % 20 < 10 ? 0 : 2))*scale + x*scale, (7*p)*scale + y*scale, 2*scale, 6*scale);


    ctx.fillRect((7*p + (frame % 20 < 10 ? 2 : 0))*scale + x*scale, (7*p)*scale + y*scale, 2*scale, 6*scale);


  }





  // Get Unity progress from DOM


  function getUnityProgressFromDOM() {


    const el = document.getElementById("unity-progress-bar-full");


    if (!el) return prog;


    const w = el.style.width || "0%";


    const num = parseFloat(w.replace("%","")) || 0;


    return Math.max(0, Math.min(1, num / 100));


  }





  function update() {


    if (!run) return;


    frame++;





    // Update progress from DOM


    prog = getUnityProgressFromDOM();





    if (!finishAnim) {


      // normal game update


      G.v += G.g;


      G.y += G.v;


      if (G.y > 0) { G.y = 0; G.v = 0; }





      G.obs.forEach(o => o.x -= G.speed);


      G.bananas.forEach(b => b.x -= G.speed);





      if (G.obs[0]?.x < -20) {


        G.obs.shift();


        spawnObstacle();


        score++;


        G.speed += 0.08;


        beep(300);


      }





      G.obs.forEach(o => {


        if (o.x < 70 && o.x + o.w > 40 && G.y === 0) {


          gameOver = true;


          beep(120, 0.2);


          if (score > high) {


            high = score;


            localStorage.lgHS = high;


          }


        }


      });





      G.bananas = G.bananas.filter(b => {


        if (b.x < 60 && b.x > 40 && G.y > -20) {


          score += 5;


          beep(800);


          return false;


        }


        return b.x > -20;


      });





      // Trigger finish animation at 98%


      if (prog >= 0.98 && !finishAnim) finishAnim = true;





    } else {


      // finish animation


      finishFrame++;


      G.y = -Math.sin(finishFrame * 0.1) * 20;


      G.bananas.forEach(b => b.y -= 2);


      if (finishFrame > 50) destroy();


    }


  }





  function draw() {


    ctx.clearRect(0, 0, canvasWidth, canvasHeight);





    if (!C.transparentBackground) {


      ctx.fillStyle = "#111";


      ctx.fillRect(0, 0, canvasWidth, canvasHeight);


    }





    // Ground = Unity progress


    ctx.fillStyle = "#333";


    ctx.fillRect(0, G.groundY*scale, G.w*scale, C.groundHeight*scale);


    ctx.fillStyle = C.unityBlue;


    ctx.fillRect(0, G.groundY*scale, G.w*prog*scale, C.groundHeight*scale);





    drawMinion(40, G.groundY - 24 + G.y);





    // Obstacles


    G.obs.forEach(o => {


      const bounce = Math.sin(frame * 0.1 + o.offset) * 2;


      ctx.fillStyle = C.obstacleColor;


      ctx.fillRect(o.x*scale, (G.groundY - 16 + bounce)*scale, o.w*scale, 16*scale);


      ctx.strokeStyle = "#800";


      ctx.strokeRect(o.x*scale, (G.groundY - 16 + bounce)*scale, o.w*scale, 16*scale);


    });





    // Bananas


    ctx.fillStyle = C.bananaColor;


    G.bananas.forEach(b => ctx.fillRect(b.x*scale, b.y*scale, 6*scale, 10*scale));





    // HUD


    ctx.fillStyle = C.unityYellow;


    ctx.font = `${14*scale}px monospace`;


    ctx.fillText(`Score ${score}`, 10*scale, 16*scale);


    ctx.fillText(`Best ${high}`, 10*scale, 32*scale);





    if (gameOver) {


      ctx.fillText("GAME OVER", 260*scale, 70*scale);


      ctx.fillText("Tap to restart", 245*scale, 90*scale);


    }


  }





  function resizeCanvas() {


    canvasWidth = window.innerWidth;


    canvasHeight = canvasWidth / ASPECT;


    if(canvasHeight > window.innerHeight) {


      canvasHeight = window.innerHeight - 40;


      canvasWidth = canvasHeight * ASPECT;


    }


    canvas.width = canvasWidth;


    canvas.height = canvasHeight;


    scale = canvasWidth / G.w;


    canvas.style.left = `${(window.innerWidth - canvasWidth)/2}px`;


    canvas.style.bottom = '20px';


  }





  function loop() {


    update();


    draw();


    raf = requestAnimationFrame(loop);


  }





  function destroy() {


    run = false;


    cancelAnimationFrame(raf);


    canvas?.remove();


    audio?.close();


  }





  // init


  canvas = document.createElement("canvas");


  canvas.style.cssText =


    "position:fixed;bottom:20px;z-index:9999;pointer-events:auto";


  document.body.appendChild(canvas);


  ctx = canvas.getContext("2d");





  window.addEventListener('resize', resizeCanvas);


  resizeCanvas();





  canvas.addEventListener("pointerdown", jump);


  reset();


  loop();





  // Expose destroy function


  window.destroyLoaderGame = destroy;





})();





	  </script>

  </body>

</html>
