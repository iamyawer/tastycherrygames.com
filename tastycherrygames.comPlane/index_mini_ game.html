<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>PlaneRacingMadness</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
  </head>
  <body>
    <div id="unity-container" class="unity-desktop">
      <canvas id="unity-canvas" width=1344 height=756></canvas>
      <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
          <div id="unity-progress-bar-full"></div>
        </div>
      </div>
      <div id="unity-warning"> </div>
      <div id="unity-footer">
        <div id="unity-webgl-logo"></div>
        <div id="unity-fullscreen-button"></div>
        <div id="unity-build-title">Plugin by <a href="https://tastycherrygames.com" rel="dofollow">Tasty <span style="color: red;">Cherry</span> Games</a></div>
      </div>
    </div>
	<script src="tastycherrygames.com.js"></script>
    <script>
      var container = document.querySelector("#unity-container");
      var canvas = document.querySelector("#unity-canvas");
      var loadingBar = document.querySelector("#unity-loading-bar");
      var progressBarFull = document.querySelector("#unity-progress-bar-full");
      var fullscreenButton = document.querySelector("#unity-fullscreen-button");
      var warningBanner = document.querySelector("#unity-warning");

      // Shows a temporary message banner/ribbon for a few seconds, or
      // a permanent error message on top of the canvas if type=='error'.
      // If type=='warning', a yellow highlight color is used.
      // Modify or remove this function to customize the visually presented
      // way that non-critical warnings and error messages are presented to the
      // user.
      function unityShowBanner(msg, type) {
        function updateBannerVisibility() {
          warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
        }
        var div = document.createElement('div');
        div.innerHTML = msg;
        warningBanner.appendChild(div);
        if (type == 'error') div.style = 'background: red; padding: 10px;';
        else {
          if (type == 'warning') div.style = 'background: yellow; padding: 10px;';
          setTimeout(function() {
            warningBanner.removeChild(div);
            updateBannerVisibility();
          }, 5000);
        }
        updateBannerVisibility();
      }

      var buildUrl = "Build";
      var loaderUrl = buildUrl + "/noads.loader.js";
      var config = {
        dataUrl: buildUrl + "/noads.data.unityweb",
        frameworkUrl: buildUrl + "/noads.framework.js.unityweb",
        codeUrl: buildUrl + "/noads.wasm.unityweb",
        streamingAssetsUrl: "StreamingAssets",
        companyName: "TastyCherryGames.com",
        productName: "PlaneRacingMadness",
        productVersion: "0.2",
        showBanner: unityShowBanner,
      };

      // By default Unity keeps WebGL canvas render target size matched with
      // the DOM size of the canvas element (scaled by window.devicePixelRatio)
      // Set this to false if you want to decouple this synchronization from
      // happening inside the engine, and you would instead like to size up
      // the canvas DOM size and WebGL render target sizes yourself.
      // config.matchWebGLToCanvasSize = false;
	   

      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        // Mobile device style: fill the whole browser client area with the game canvas:

        var meta = document.createElement('meta');
        meta.name = 'viewport';
        meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
        document.getElementsByTagName('head')[0].appendChild(meta);
        container.className = "unity-mobile";
        canvas.className = "unity-mobile";

        // To lower canvas resolution on mobile devices to gain some
        // performance, uncomment the following line:
        // config.devicePixelRatio = 1;

        //tcg unityShowBanner('WebGL builds are not supported on mobile devices.');
      } else {
        // Desktop style: Render the game canvas in a window that can be maximized to fullscreen:

        canvas.style.width = "1344px";
        canvas.style.height = "756px";
		//tastycherrygames.com
		resize_tasty_cherry();
		window.addEventListener('resize', resize_tasty_cherry);
      }
	

      loadingBar.style.display = "block";

      var script = document.createElement("script");
      script.src = loaderUrl;
      script.onload = () => {
        createUnityInstance(canvas, config, (progress) => {
          progressBarFull.style.width = 100 * progress + "%";
        }).then((unityInstance) => {
		  gameInstance=unityInstance;
		  checkMobileWebGL();
          loadingBar.style.display = "none";
          fullscreenButton.onclick = () => {
            unityInstance.SetFullscreen(1);
          };
        }).catch((message) => {
          alert(message);
        });
      };
      document.body.appendChild(script);
    </script>
	<!--<script src="https://tastycherrygames.com/games/js/runtimejs.js"></script> -->

	  <script>
		  (function () {
  const C = {
    transparentBackground: true, // false = solid background
    unityYellow: "#fbc02d",
    unityBlue: "#1e88e5",
    obstacleColor: "#ff6b6b",    // soft red
    bananaColor: "#ffd54f",
    groundHeight: 6
  };

  let canvas, ctx, raf, audio;
  let score = 0, high = +localStorage.lgHS || 0;
  let gameOver = false, run = true, prog = 0, frame = 0;
  let finishAnim = false, finishFrame = 0;

  const ASPECT = 600 / 180;
  let canvasWidth, canvasHeight, scale = 1;

  const G = {
    w: 600, h: 180,
    groundY: 140,
    y: 0, v: 0, g: 0.8, j: -12,
    speed: 4,
    obs: [],
    bananas: []
  };

  const minion = [
    "0011111100",
    "0111111110",
    "1111111111",
    "1100110011",
    "1111111111",
    "0111111110",
    "0011111100"
  ];

  function beep(f = 400, d = 0.05) {
    audio ||= new AudioContext();
    const o = audio.createOscillator();
    const g = audio.createGain();
    o.frequency.value = f;
    g.gain.value = 0.05;
    o.connect(g);
    g.connect(audio.destination);
    o.start();
    o.stop(audio.currentTime + d);
  }

  function spawnObstacle() {
    G.obs.push({ x: G.w + 200, w: 12, offset: Math.random() * 4 });
    if (Math.random() < 0.5)
      G.bananas.push({ x: G.w + 260, y: G.groundY - 38 });
  }

  function reset() {
    G.y = G.v = 0;
    G.speed = 4;
    G.obs = [];
    G.bananas = [];
    score = 0;
    gameOver = false;
    for (let i = 0; i < 3; i++) spawnObstacle();
  }

  function jump() {
    if (gameOver) return reset();
    if (G.y === 0) {
      G.v = G.j;
      beep(600);
    }
  }

  function drawMinion(x, y) {
    const p = 3;
    minion.forEach((r, ry) => {
      [...r].forEach((c, rx) => {
        if (c === "1") {
          ctx.fillStyle = C.unityYellow;
          ctx.fillRect((x + rx * p) * scale, (y + ry * p) * scale, p * scale, p * scale);
        }
      });
    });

    ctx.fillStyle = "#ccc"; // goggles
    ctx.fillRect(3*p*scale + x*scale, 3*p*scale + y*scale, 2*p*scale, p*scale);
    ctx.fillRect(6*p*scale + x*scale, 3*p*scale + y*scale, 2*p*scale, p*scale);

    ctx.fillStyle = "#000"; // eyes
    ctx.fillRect(4*p*scale + x*scale, 4*p*scale + y*scale, p*scale, p*scale);
    ctx.fillRect(7*p*scale + x*scale, 4*p*scale + y*scale, p*scale, p*scale);

    // animated legs
    ctx.fillStyle = C.unityBlue;
    ctx.fillRect((3*p + (frame % 20 < 10 ? 0 : 2))*scale + x*scale, (7*p)*scale + y*scale, 2*scale, 6*scale);
    ctx.fillRect((7*p + (frame % 20 < 10 ? 2 : 0))*scale + x*scale, (7*p)*scale + y*scale, 2*scale, 6*scale);
  }

  // Get Unity progress from DOM
  function getUnityProgressFromDOM() {
    const el = document.getElementById("unity-progress-bar-full");
    if (!el) return prog;
    const w = el.style.width || "0%";
    const num = parseFloat(w.replace("%","")) || 0;
    return Math.max(0, Math.min(1, num / 100));
  }

  function update() {
    if (!run) return;
    frame++;

    // Update progress from DOM
    prog = getUnityProgressFromDOM();

    if (!finishAnim) {
      // normal game update
      G.v += G.g;
      G.y += G.v;
      if (G.y > 0) { G.y = 0; G.v = 0; }

      G.obs.forEach(o => o.x -= G.speed);
      G.bananas.forEach(b => b.x -= G.speed);

      if (G.obs[0]?.x < -20) {
        G.obs.shift();
        spawnObstacle();
        score++;
        G.speed += 0.08;
        beep(300);
      }

      G.obs.forEach(o => {
        if (o.x < 70 && o.x + o.w > 40 && G.y === 0) {
          gameOver = true;
          beep(120, 0.2);
          if (score > high) {
            high = score;
            localStorage.lgHS = high;
          }
        }
      });

      G.bananas = G.bananas.filter(b => {
        if (b.x < 60 && b.x > 40 && G.y > -20) {
          score += 5;
          beep(800);
          return false;
        }
        return b.x > -20;
      });

      // Trigger finish animation at 98%
      if (prog >= 0.98 && !finishAnim) finishAnim = true;

    } else {
      // finish animation
      finishFrame++;
      G.y = -Math.sin(finishFrame * 0.1) * 20;
      G.bananas.forEach(b => b.y -= 2);
      if (finishFrame > 50) destroy();
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    if (!C.transparentBackground) {
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    }

    // Ground = Unity progress
    ctx.fillStyle = "#333";
    ctx.fillRect(0, G.groundY*scale, G.w*scale, C.groundHeight*scale);
    ctx.fillStyle = C.unityBlue;
    ctx.fillRect(0, G.groundY*scale, G.w*prog*scale, C.groundHeight*scale);

    drawMinion(40, G.groundY - 24 + G.y);

    // Obstacles
    G.obs.forEach(o => {
      const bounce = Math.sin(frame * 0.1 + o.offset) * 2;
      ctx.fillStyle = C.obstacleColor;
      ctx.fillRect(o.x*scale, (G.groundY - 16 + bounce)*scale, o.w*scale, 16*scale);
      ctx.strokeStyle = "#800";
      ctx.strokeRect(o.x*scale, (G.groundY - 16 + bounce)*scale, o.w*scale, 16*scale);
    });

    // Bananas
    ctx.fillStyle = C.bananaColor;
    G.bananas.forEach(b => ctx.fillRect(b.x*scale, b.y*scale, 6*scale, 10*scale));

    // HUD
    ctx.fillStyle = C.unityYellow;
    ctx.font = `${14*scale}px monospace`;
    ctx.fillText(`Score ${score}`, 10*scale, 16*scale);
    ctx.fillText(`Best ${high}`, 10*scale, 32*scale);

    if (gameOver) {
      ctx.fillText("GAME OVER", 260*scale, 70*scale);
      ctx.fillText("Tap to restart", 245*scale, 90*scale);
    }
  }

  function resizeCanvas() {
    canvasWidth = window.innerWidth;
    canvasHeight = canvasWidth / ASPECT;
    if(canvasHeight > window.innerHeight) {
      canvasHeight = window.innerHeight - 40;
      canvasWidth = canvasHeight * ASPECT;
    }
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    scale = canvasWidth / G.w;
    canvas.style.left = `${(window.innerWidth - canvasWidth)/2}px`;
    canvas.style.bottom = '20px';
  }

  function loop() {
    update();
    draw();
    raf = requestAnimationFrame(loop);
  }

  function destroy() {
    run = false;
    cancelAnimationFrame(raf);
    canvas?.remove();
    audio?.close();
  }

  // init
  canvas = document.createElement("canvas");
  canvas.style.cssText =
    "position:fixed;bottom:20px;z-index:9999;pointer-events:auto";
  document.body.appendChild(canvas);
  ctx = canvas.getContext("2d");

  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  canvas.addEventListener("pointerdown", jump);
  reset();
  loop();

  // Expose destroy function
  window.destroyLoaderGame = destroy;

})();

	  </script>
  </body>
</html>
